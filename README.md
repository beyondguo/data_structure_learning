# 数据结构学习（C/C++）

笔记和代码根据**郝斌**老师的网络课程整理，代码部分不完全跟老师课堂上一致，但思路基本一致。

另外在cpp文件中，添加了大量的注释，可以直接当做笔记阅读。



> 课堂笔记摘录：

## 一、基本概念

**数据结构定义**：
我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找、删除、排序）而执行的相应操作，这个操作就是算法。
说白了，就是如何把一个个数据，以及数据之间的关系存储到内存中。

**衡量算法的标准**:

1. 时间复杂度（程序要执行的次数，而非确定时间）
2. 空间复杂度（算法执行过程中所占用的最大内存）
3. 难易程度
4. 健壮性

狭义的算法跟数据存储有关；
广义的算法跟数据存储无关；
何谓**泛型**：
即某种技术，可以使得不同的存储方式，执行的操作是一样的。

**预备知识**：

- 指针：
指针是C语言的灵魂。
定义：就是地址，内存单元的编号，从0开始的非负整数，0 -- FFFFFFFF（4G-1）【？？】
指针就是地址，地址就是指针。
指针的本质是一个操作受限的非负整数。
**指针变量**是存放内存单元地址的变量！





## 二、线性结构

 把所有的节点用一根线连起来的结构。
**连续存储**-->数组
  优点：存取速度快
  缺点：插入删除慢，事先必须知道数组长度，需要大块连续内存
**离散存储**-->链表
  优点：插入删除快，不用事先定义长度
  缺点：存取速度慢

线性结构的两种常见应用：栈，队列。


### 链表：
首节点：第一个有效节点
尾结点：最后一个有效节点
头结点 ：数据类型和首节点一样。首节点之前的一个节点，不存放有效数据，其作用是为了方便链表的操作。
头指针：指向头结点的指针变量，是头结点的地址
尾指针：指向尾结点的指针变量

>要对一个链表进行处理，需要知道的参数：头指针。
>只需要这么一个玩意儿就够了，就可以知道所有的数据，以及链表的长度等信息。

**链表的分类：**
单链表
双链表：每一个节点有两个指针域
循环链表：能通过任何一个节点，找到所有其他节点
非循环链表


### 栈
**定义**：一种可以实现先进后出的存储结构，类似于箱子。

**分类：**
    静态栈：以数组为基本内核
    动态栈：以链表为基本内核

**动态栈的算法：**
就是把链表的一些功能给砍掉，例如不允许在头部插入，不允许删除中间的元素等等。
    出栈
    压栈（入栈）

![图片.png](https://upload-images.jianshu.io/upload_images/5118838-3886d6746fe28850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

**栈的应用：**

- 函数调用就是考栈的思路实现的。
  f调用g，g调用k；
  执行的时候，先执行k，再g再f
- 中断
- 表达式求值 （两个栈可以编写计算器）
- 内存分配
- 缓冲处理
- 迷宫


### 队列
**定义**：一种够可以实现“先进先出”的数据结构
**分类**：
    链式队列
    静态队列
        静态队列通常都必须是循环队列

**静态队列需要搞清楚的几个点：**

1. **为啥必须是循环队列**
    如果按照普通的数组去形成队列的话，那删除元素后，front的位置就会往上移动，队列的前面就会空出来位置，这些位置就浪费了。如果添加元素，那rear也会往上移动。这样的结果就是，无论是入队还是出队，两个都往上移，空间就越来越少，操作不方便。
所以，关键是需要，在添加元素的时候，如果rear已经到顶部，rear可以从上面跳到下面接上去。

2. **循环队列需要几个参数来确定**
       两个，front和rear，front（前台）掌管出对，rear掌管入对，在不同场合中：
       1).  队列初始化：两者都为零
       2).  队列非空：
             front代表的是队列的第一个元素
             rear代表的是队列的最后一个有效元素的下一个位置
       3).  队列空：front和rear的值相等，但不一定为零
3. **循环队列各个参数的含义**
4. **入对，出对算法**
       入队：

   ```
1.把新增元素添加到当前r的位置
2.r = (r+1)%maxlen
   ```
​          出队：

```
f = (f+1)%maxlen
```
5. **如何判断空、满**
       空：front与rear的值相等，就一定为空
       满：这个有点难判断，因为满的时候，似乎f也跟r相同了。
   这个时候有两种办法处理：一种是添加一个参数，记录元素个数。第二种就是，不让队列的所有位置都可以放值，而是始终空出一个位置，让r的永远是一个空位置。这样，满的状态就是`r==(f-1)%maxlen`或者`f==(r+1)%maxlen`。

**队列的应用**：
所有和时间有关的操作都有队列的影子。



